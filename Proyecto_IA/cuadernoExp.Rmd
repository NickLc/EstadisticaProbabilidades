---
title: "Cuaderno de experimentos"
output: html_notebook
---


En este cuaderno se registrará la evolución del trabajo cual si fuera un trabajo de campo.

# Problema: Como almacenar los mapas.
Es preciso encontrar una forma de interpretar los mapas para que la computadora pueda graficarlos.
Encontramos que la librería "rgdal" que es capaz de procesar archivos .shp([ERSI Shapefile](https://es.wikipedia.org/wiki/Shapefile))
Graficarlo es tan sencillo como usar la función plot()

```{r}
mapa1 <- readOGR(file.choose())
plot(mapa1)
```
# Como colorear el mapa
El colorear el mapa también es cuestión de plot. Se requiere especificar el color de cada departamento en un array de enteros donde cada número representa un color.
```{r}
plot(mapa1, col = rep(3, length(mapa1)))
plot(mapa1, col = c(2,3,4, rep(5, length(mapa1) - 3)))
```
# Problema crítico: Modelamiento
Ahora bien, el computador identifica las regiones y las colorea. Es de vital importancia para el proyecto que el computador identifique cuáles regiones son adyacentes a una región determinado.
Por teoría de matemática discreta, la herramienta matemática que más se acopla a lo que deseamos es el grafo, debido a la posibilidad de representar las regiones como nodos conectados solamente si estás son adyacentes, y también por la teoría de coloración de grafos parcialmente estudiada en el curso de matemática discreta.
Es preciso, pues, obtener la matriz de adyacencia del mapa.

## Calculo manual de la matriz de adyacencia
Para esto, buscamos los centros.

```{r}
centros <- coordinates(mapa1)
masProx <- knn2nb(knearneigh(centros))
ref <- quantile(unlist(nbdists(masProx, centros)),.99)
proxim <- dnearneigh(centros, 0, ref)

plot(mapa1)
plot(proxim, centros, add = TRUE, col = "red")
```
Vemos que realmente no hemos encontrado la matriz de adyacencia del mapa. *Intento fallido...*

## Calculo automático
Encontramos la librería "rgeos" que nos proporciona herramientas para llegar a la matriz de adyacencia de un mapa a partir del archivo .shp mediante la función gIntersects();
```{r}
adyacencia <- gIntersects(mapa1, byid=TRUE)## Matriz de adyacencia
adyacencia
# transformamos la matriz de adyacencia a una de 0 y 1
adyacencia[which(adyacencia == TRUE)] = 1
adyacencia
```

## En busqueda de la función de coloración
Ahora es preciso encontrar la función que nos permita colorear el mapa con 4 colores. Elegimos el backtracking como primera opción.

```{r}
color <- rep(0,length(mapa1))


correcto <- function(color, k) {
  if (k==1) return (TRUE)
  for(j in 1:(k-1)) {
    if(adyacencia[j,k]==1){  # comprueba que son adyacentes
      if(color[k]==color[j]) # comprueba que tienen el mismo color
        return(FALSE)
    }
  }
  return(TRUE)
  
}

# K recorre las columnas de adya y de color.

k=1
errores=0
while(k<=length(color)){
  color[k]=1
  while(!correcto(color,k)){ # mientras la asignacion de color sea inadecuada.
    color[k]=color[k]+1
    errores=errores+1;
  }
  if(errores==4) k=k-1
  k=k+1
}

plot(mapa1, col = color)


```




